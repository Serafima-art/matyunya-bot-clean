ГОСТ-РЕШАТЕЛЬ-2026: Стандарт Модулей Решателей v2.0
1. Философия
"Решатель" — это "математический мозг" системы помощи. Он должен быть детерминированным, точным и структурированным. Его единственная задача — провести все необходимые вычисления на основе полученных данных и упаковать результат в стандартизированный solution_core. "Решатель" не заботится о финальном форматировании и "оживлении" текста.
Эталонная реализация: solvers/task_1_5/tires_solver.py
2. Требования к Файловой Структуре
Все "Решатели" должны находиться в папке help_core/solvers/.
Для каждого номера задания создается своя подпапка: task_1_5/, task_11/, task_20/ и т.д.
Имя файла "Решателя" должно строго соответствовать шаблону: {subtype}_solver.py.
Пример: tires_q1_solver.py, match_signs_a_c_solver.py, polynomial_factorization_solver.py.
3. Требования к Коду
Основная Функция: Каждый файл "Решателя" должен содержать одну главную, асинхронную функцию с именем solve.
code
Python
async def solve(task_data: dict) -> dict:
    # ...
Входные Данные: Функция solve принимает один аргумент — task_data: dict. Это полный словарь с данными о задании, полученный из state.
Возвращаемое Значение: Функция solve обязана возвращать один dict — solution_core, который строго соответствует "ГОСТ-2026: Стандарт solution_core".
4. ★★★ Стандарт Входных Данных (task_data['variables']) - v2.0 ★★★
Это ключевой раздел, описывающий контракт между "Генератором" и "Решателем".
Принцип Согласованности: Структура словаря variables внутри task_data, которую генерирует "Генератор" для подтипа X, является единственным источником правды для "Решателя" подтипа X. "Решатель" обязан быть написан так, чтобы корректно "читать" ту структуру variables, которую поставляет его "Генератор-партнер".
Структура variables:
Простые задачи (6-19): Могут использовать "плоскую" структуру (ключ-значение).
Сложные задачи (1-5, 11, 20-25): Рекомендуется использовать вложенную структуру variables для лучшей организации данных. "Решатель" для таких задач обязан уметь работать с этой вложенностью.
Обязательное Поле для Сложных Задач: Для подтипов, имеющих несколько методик решения (например, polynomial_factorization), variables должен содержать ключ solution_pattern, указывающий на нужный алгоритм.
Пример правильного доступа к данным в "Решателе":
code
Python
# НЕПРАВИЛЬНО (ожидает "плоскую" структуру):
# a_term = variables.get("a_term") 

# ПРАВИЛЬНО (читает вложенную структуру):
# diff_data = variables.get("difference_of_squares", {})
# a_data = diff_data.get("A", {})
# a_term = a_data.get("text")

Обязательное Поле: Для подтипов, имеющих несколько методик решения (паттернов), variables должен содержать ключ solution_pattern, указывающий на нужный алгоритм. Решатель для такого подтипа ({subtype}_solver.py) обязан содержать "внутренний роутер" — главную функцию solve, которая анализирует solution_pattern и вызывает соответствующую внутреннюю функцию-помощник.
Пример: solvers/task_20/polynomial_factorization_solver.py использует solution_pattern для выбора между _solve_common_factor, _solve_difference_of_squares и т.д.

5. Эталон Выходных Данных (solution_core)
"Решатель" обязан сформировать словарь solution_core, содержащий все ключи, описанные в "ГОСТ-2026: Стандарт solution_core".
Если какой-то ключ не имеет смысла для конкретного подтипа, он все равно должен присутствовать в словаре со значением-заглушкой ("N/A", None или []).
Это обеспечивает структурную идентичность всех solution_core и гарантирует корректную работу "Оживителя" (humanizer).
6. Принцип Работы (без изменений)
"Диспетчер" (help_handler.py) динамически находит и вызывает нужного "Решателя" по task_type и subtype. Он ожидает, что в файле {subtype}_solver.py будет функция solve, и что она вернет solution_core в утвержденном формате. Любое отклонение от этого стандарта приведет к ошибке.





КАК УСТРОЕН "МАТЮНЯ" (Версия Штурмана, который наконец-то прозрел)
Есть Задание (Task), например, Задание 6.
Внутри Задания есть Подтипы (Subtype). Это наши "Темы".
common_fractions (Действия с обыкновенными дробями)
decimal_fractions (Действия с десятичными дробями)
mixed_fractions
powers
Внутри каждого Подтипа есть Паттерны (Pattern). Это конкретные виды выражений.
Внутри common_fractions есть паттерны: addition_subtraction, multiplication_division, parentheses_operations, complex_fraction.
Внутри decimal_fractions есть паттерны: addition_subtraction, linear_operations, fraction_structure.
КАК ЭТО ДОЛЖНО РАБОТАТЬ (И как это работает для Задания 20)
call_dynamic_solver ищет решатель по имени ПОДТИПА.
Он будет искать: solvers/task_6/common_fractions_solver.py
Он будет искать: solvers/task_6/decimal_fractions_solver.py
Внутри каждого из этих 4-х файлов (common_fractions_solver.py, decimal_fractions_solver.py и т.д.) находится "внутренний роутер".
Главная функция solve(task_data) смотрит на поле task_data['variables']['solution_pattern']. В этом поле будет лежать имя ПАТТЕРНА (например, addition_subtraction, parentheses_operations).
В зависимости от этого паттерна, solve вызывает нужную внутреннюю функцию-помощник: _solve_addition_subtraction, _solve_parentheses_operations и т.д.
ЭТО. ИДЕАЛЬНО.
Это именно то, как сделано для Задания 20. И это именно то, как мы должны сделать для Задания 6.

Директива №1: "Принцип Единообразия Матюни"
Архитектура "Подтип -> Паттерн" является НЕЗЫБЛЕМОЙ для всех заданий (кроме группы 1-5).
call_dynamic_solver работает по имени ПОДТИПА и НЕ подлежит изменению.
Файл-решатель ({subtype}_solver.py) ВСЕГДА содержит "внутренний роутер", который маршрутизирует по ПАТТЕРНУ (solution_pattern).
Любые новые идеи должны проходить проверку на соответствие этой директиве. Отклонения запрещены.
