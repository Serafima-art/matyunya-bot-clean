Документация: Модульная Архитектура Задания 12 ("Фабрика с ОТК")
1. Общее описание
Этот документ описывает финальную архитектуру и логику работы модуля для Задания 12 ("Работа с формулами"). Система спроектирована по принципу "Фабрика с Отделом Технического Контроля (ОТК) и Складом Готовой Продукции".
Главная цель этой архитектуры — обеспечить максимальную надежность, полноту покрытия и простоту поддержки, избежав проблем с "хрупкостью", с которыми мы столкнулись при попытке внедрения более сложных систем.
2. Архитектура ("Надежный Завод")
Система построена на принципе полного разделения этапов Производства и Эксплуатации.
2.1. Производственный Комплекс
Эти модули используются один раз для наполнения "склада" и не задействуются при работе бота с пользователем.
py_generators/task_12_generator.py ("Производственный цех"):
Роль: Содержит 66+ "маленьких" функций-генераторов, по одной на каждый уникальный "сюжет" из нашего финального списка.
Логика: Каждая функция генерирует "красивые" числа, подгоняет под них условие задачи и вычисляет ответ. Использует простые, стандартизированные академические тексты.
Ключевой элемент: "Карта дирижера" GENERATOR_MAP, которая связывает subtype_key с соответствующей функцией.
task_generators/task_12/task_12_validator.py ("Отдел Технического Контроля - ОТК"):
Роль: Проводит 100% независимую проверку каждой задачи, произведенной "цехом".
Логика: Содержит 66+ "зеркальных" методов-валидаторов. Каждый метод использует "жесткое" регулярное выражение, идеально подогнанное под текст своего "визави" из генератора. Он извлекает числа и самостоятельно, по своей формуле пересчитывает ответ.
Принцип: Полная математическая и логическая независимость от Генератора.
scripts/populate_task_12_db.py ("Директор Фабрики"):
Роль: Оркестрирует весь производственный процесс.
Логика:
В цикле заказывает у Generator'а партию задач для каждого subtype_key.
Каждую сгенерированную задачу немедленно отправляет в Validator на проверку.
Если ответы совпадают, "Директор" присваивает задаче id, добавляет поля category и subcategory и кладет ее на "склад".
Если ответы не совпадают, "Директор" останавливает конвейер и сообщает о браке.
2.2. Эксплуатационный Комплекс (то, с чем работает бот)
data/tasks_12.json ("Склад Готовой Продукции"):
Роль: Единственный, финальный файл, содержащий тысячи полностью готовых, проверенных и обогащенных метаданными задач.
Структура: Каждая задача — это JSON-объект, содержащий id, task_type, subtype, category, subcategory, text и answer.
loader.py ("Кладовщик"):
Роль: При старте бота один раз загружает tasks_12.json (и другие базы) в оперативную память (глобальный словарь TASKS_DB).
Цель: Обеспечить мгновенный доступ к задачам без постоянного чтения файлов с диска.
keyboards/.../TASK_12_MAP.py ("Карта Склада"):
Роль: "Мост" между навигацией и базой данных.
Логика: Python-словарь, который четко определяет, какие subtype'ы из tasks_12.json соответствуют какой кнопке в меню (например, ключу equations:geometry).
handlers/.../task_12_handler.py ("Работник Склада"):
Роль: Обрабатывает нажатия кнопок пользователем.
Логика:
Получает callback_data от кнопки (например, task:12:level2:equations:geometry).
С помощью TASK_12_MAP находит список нужных subtype'ов.
Фильтрует TASKS_DB["12"] по этому списку.
Выбирает случайную задачу и отправляет ее пользователю.
Сохраняет полный объект задачи в FSM для последующей проверки и логирования.
3. Процесс Работы с Пользователем
Выбор: Пользователь нажимает кнопки навигации.
Поиск по Карте: task_12_handler использует TASK_12_MAP, чтобы понять, какие subtype'ы нужно найти.
Выдача со Склада: Хендлер мгновенно находит подходящие задачи в TASKS_DB и отправляет случайную из них.
Сохранение в "Накладную": Полная информация о выданной задаче сохраняется в FSM.
Проверка и Логирование: Другой хендлер принимает ответ, сравнивает с данными из FSM и записывает результат в AnswerLog по принципу гибридной аналитики (сохраняя полные данные только в случае ошибки).
Эта архитектура является результатом долгого анализа и отладки и представляет собой оптимальный баланс между надежностью, полнотой и производительностью для заданий с большим количеством фиксированных "сюжетов".