# Документация: Модуль Решателей для Заданий 1-5 ("Шины")

**Файл:** `help_core/solvers/tires_solvers.py`
**Версия:** 2.1 (Финальная, после полной отладки)
**Дата:** 18.09.2025

## 1. Философия и Архитектура

Модуль `tires_solvers.py` является "математическим мозгом" для всех задач, связанных с подтипом "Шины". Его главная задача — производить все необходимые вычисления и возвращать результат в унифицированном, "сухом" формате `solution_core`, который затем передается "Оживителю" (GPT) для форматирования.

### Ключевые Принципы:
- **Чистота Данных:** Решатели работают только с числами и логикой. Они не занимаются форматированием текста (HTML-тегами, эмодзи, Markdown) и возвращают "сырые" текстовые строки.
- **Безопасность:** Все функции спроектированы так, чтобы быть "пуленепробиваемыми". Доступ к входным данным (`task_package`, `plot_data`) осуществляется только через безопасный метод `.get()`, что предотвращает падения из-за отсутствия ключей.
- **Переиспользование Кода (DRY):** Общие, повторяющиеся операции (расчет диаметра, парсинг маркировки) вынесены в отдельные вспомогательные функции, которые используются всеми остальными.
- **Следование "Стандарту Отчета":** Каждая функция-решатель возвращает словарь `solution_core`, структура которого строго регламентирована.

---

## 2. Вспомогательные ("Сервисные") Функции

Эти функции являются общими для всего модуля и вынесены на верхний уровень файла для использования всеми решателями.

### `_parse_tire_marking(tire_str: str) -> tuple`
- **Назначение:** "Расшифровывает" стандартную маркировку шины.
- **Вход:** Строка, например, `"205/55 R17"`.
- **Выход:** Кортеж из четырех элементов: `(ширина, профиль, диаметр, исходная_строка)`, например, `(205, 55, 17, "205/55 R17")`.
- **Особенности:** Безопасна. Если строка некорректная, возвращает нули `(0, 0, 0, ...)`, что предотвращает падение в вызывающих функциях.

### `calculate_tire_diameter(B: float, H: float, d: float) -> float`
- **Назначение:** Вычисляет полный диаметр колеса в миллиметрах по стандартной формуле.
- **Вход:**
    - `B`: Ширина шины в мм.
    - `H`: Высота профиля в процентах.
    - `d`: Диаметр диска в дюймах.
- **Выход:** Диаметр колеса в `мм` (float).
- **Формула:** `(B * H / 100) * 2 + d * 25.4`.

---

## 3. Основные Функции-Решатели

Каждая из этих функций принимает на вход полный `task_package` и возвращает `solution_core`. Они спроектированы так, чтобы извлекать необходимые им данные из `plot_data['task_specific_data']['task_X_data']`.

### `solve_q1_tires(task_package: dict) -> dict`
- **Назначение:** Решает Задание 1 — поиск в таблице разрешенных размеров шин.
- **Логика:**
    1.  Из `task_1_data` определяется тип вопроса (`question_type`): ищем мы минимальную/максимальную **ширину** для заданного диаметра, или минимальный/максимальный **диаметр** для заданной ширины.
    2.  Происходит итерация по словарю `allowed_tire_sizes`.
    3.  Собирается список всех подходящих значений (ширин или диаметров).
    4.  Из этого списка выбирается минимальное или максимальное значение.
- **Особенности:** Не использует `_parse_tire_marking`, так как работает с уже структурированными данными таблицы.

### `solve_q2_tires(task_package: dict) -> dict`
- **Назначение:** Решает Задание 2 — сравнение двух шин (на сколько `мм` отличается их радиус или диаметр).
- **Логика:**
    1.  Из `task_2_data` извлекаются маркировки двух шин (`tire_1`, `tire_2`) и тип сравнения (`comparison_type`).
    2.  С помощью `_parse_tire_marking` обе маркировки "расшифровываются".
    3.  С помощью `calculate_tire_diameter` вычисляются диаметры обоих колес.
    4.  Находится абсолютная разница диаметров `abs(D1 - D2)`.
    5.  Если `comparison_type` содержит слово "radius", разница делится на 2.
- **Округление:** Финальный ответ округляется до **2 знаков** после запятой.

### `solve_q3_tires(task_package: dict) -> dict`
- **Назначение:** Решает Задание 3 — расчет диаметра одного конкретного колеса.
- **Логика:**
    1.  Из `task_3_data` извлекается маркировка искомой шины (`tire_marking`).
    2.  С помощью `_parse_tire_marking` маркировка "расшифровывается".
    3.  С помощью `calculate_tire_diameter` вычисляется ее диаметр в `мм`.
- **Особенности:** В зависимости от текста вопроса в `plot_data`, решатель может быть настроен на возврат ответа в `мм` или `см` (требует проверки `calculation_steps`).
- **Округление:** До **2 знаков** после запятой.

### `solve_q4_tires(task_package: dict) -> dict`
- **Назначение:** Решает Задание 4 — нахождение величины изменения диаметра при замене шин.
- **Логика:** Практически идентична `solve_q2_tires`, но всегда работает с **диаметрами**.
    1.  Из `task_4_data` извлекаются маркировки старой (`original_tire`) и новой (`replacement_tire`) шин.
    2.  Рассчитываются их диаметры.
    3.  Находится разница `D_new - D_old` (знак важен, он показывает увеличение или уменьшение).
- **Округление:** До **1 знака** после запятой.

### `solve_q5_tires(task_package: dict) -> dict`
- **Назначение:** Решает Задание 5 — нахождение процентного изменения пробега за один оборот колеса.
- **Логика:**
    1.  Из `task_5_data` извлекаются маркировки старой и новой шин.
    2.  Рассчитываются их диаметры `D_old` и `D_new`.
    3.  Вычисляются длины окружностей `L = π * D` для обоих колес.
    4.  Процентное изменение находится по формуле: `((L_new - L_old) / L_old) * 100`.
- **Особенности:** Содержит защиту от деления на ноль, если диаметр старого колеса равен 0.
- **Округление:** До **1 знака** после запятой (как правило, требуется в задачах ОГЭ).

### `solve_q6_tires(task_package: dict) -> dict`
- **Назначение:** Решает Задание 6 — выбор самого выгодного шиномонтажа.
- **Логика:**
    1.  Из `task_6_data` (или `task_5_data` для совместимости) извлекаются данные о сервисах (`service_choice_data`).
    2.  Для каждого сервиса в цикле рассчитывается полная стоимость.
    3.  Стоимость работы на одно колесо = сумма всех операций (`removal`, `balancing` и т.д.).
    4.  Общая стоимость работы = (Стоимость на одно колесо) * (Количество колес).
    5.  Полная стоимость = (Общая стоимость работы) + (Стоимость дороги `road_cost`).
    6.  Находится минимальное значение среди всех полных стоимостей.
- **Округление:** Финальный ответ округляется до **целого числа**.