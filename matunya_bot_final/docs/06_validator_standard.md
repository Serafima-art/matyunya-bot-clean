# ГОСТ-ВАЛИДАТОР-2025: Единый Стандарт Функций Валидации

## 1. Философия

Все валидаторы в проекте "Матюня" следуют принципу **максимальной информативности и предсказуемости**. Они не просто отвечают на вопрос "правильно ли?", а предоставляют полный отчет о состоянии проверяемых данных.

## 2. Сигнатура Функции

Каждая главная функция-валидатор должна иметь следующую сигнатуру (type hint):

```python
from typing import Dict, Any, Tuple, List

def validate_... (task: Dict[str, Any]) -> Tuple[bool, List[str]]:
    # ...
Аргументы:
task: Dict[str, Any]: Словарь с полными данными сгенерированного задания.
Возвращаемое значение:
Tuple[bool, List[str]]: Кортеж, состоящий строго из двух элементов.
3. Структура Возвращаемого Значения
Элемент 1: is_valid (bool)
True: Если проверка прошла успешно, и ни одной ошибки не найдено.
False: Если в ходе проверки была найдена хотя бы одна ошибка.
Это "зеленая/красная лампочка", которая дает немедленный и однозначный ответ о статусе валидации.
Элемент 2: errors (List[str])
Это список, содержащий текстовые описания всех найденных ошибок.
В случае успеха (когда is_valid равно True), этот список должен быть пустым ([]).
В случае провала (когда is_valid равно False), этот список должен содержать одну или несколько строк, где каждая строка — это понятное описание конкретного дефекта.
4. Пример Реализации
code
Python
def validate_example_task(task: dict) -> Tuple[bool, List[str]]:
    errors = []

    if task.get("task_type") != 99:
        errors.append("Неверный task_type. Ожидался 99.")
    
    if "answer" not in task:
        errors.append("В задании отсутствует ключ 'answer'.")
    
    # ... другие проверки, добавляющие ошибки в список ...

    # Финальная логика возврата
    is_valid = len(errors) == 0
    return is_valid, errors
5. Использование в Коде (Пример для populate)
Код, вызывающий валидатор, должен быть построен на основе этого стандарта:
code
Python
is_valid, errors = validator(task)

if not is_valid:
    print(f"[WARN] Найдены ошибки:")
    for err in errors:
        print(f"   • {err}")
    continue # Пропускаем "бракованную" задачу